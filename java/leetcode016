public class leetcode016 {
    //环形路上有n个加油站，第i个加油站的汽油量是gas[i].
    //你有一辆车，车的油箱可以无限装汽油。从加油站i走到下一个加油站（i+1）花费的油量是cost[i]，你从一个加油站出发，刚开始的时候油箱里面没有汽油。
    //求从哪个加油站出发可以在环形路上走一圈。返回加油站的下标，如果没有答案的话返回-1。
    //注意：
    //答案保证唯一。

    //很牛的思路，让我想起了之前做过的某个题
    /*
思路：
累加在每个位置的left += gas[i]-cost[i].就是在每个位置剩余的油量，如果left一直大于0，
则可一直走下去，如果left小于0,那么就从下一个位置重新开始计数，并且将之前欠下的多少记录下来，
如果最终遍历完数组剩下的燃料足以弥补之前不够的，那么就可以到达，并返回最后一次开始的位置，否则返回-1；


论证这种方法的正确性：
1，如果从头开始，每次累计剩下的油量都为整数，那么没有问题，它可以从头开到结束
2. 如果到中间的某个位置，剩余的油量为负了，那么说明之前积累下来的油量不够从这一战
到下一站，那么就从下一站从新开始计数，为什么从下一站，而不是从之前的谋战呢？
因为第一站剩余的油量肯定大于等于0的，然而到当前油量变负了，说明从第一站之后开始的话当前油量只会更少
不会怎加，也就说从第一站之后，当前站之前的某站出发到当前站之前的某站出发到当前站出发的剩余
的油量是不大可能大于0的，所以只能从下一站重新出发开始计算从下一站开始剩余的油量
并且把之前欠下的油量也累加起来，看到最后剩余的油量是不是大于欠下的油量。
     */

    public int canCompleteCircuit(int[] gas, int[] cost) {
      int left=0,start=0,lack=0;
      for(int i=0;i<gas.length;i++ ){
          left+=gas[i]-cost[i];
          if(left<0){
              lack+=left;
              left=0;
              start=i+1;
          }
      }
      return left+lack>=0?start:-1;
    }
}
