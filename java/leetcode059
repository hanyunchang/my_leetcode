import java.util.ArrayList;

public class leetcode059 {
    //格雷码是一种二进制编码系统，如果任意两个相邻的代码只有一位二进制数不同，则称这种编码为格雷码（Gray Code）。
    //给定一个非负整数n，表示代码的位数，打印格雷码的序列。格雷码序列必须以0开头。
    //例如：给定n=2，返回[0,1,3,2]. 格雷码的序列为：
    //00 - 0↵01 - 1↵11 - 3↵10 - 2
    //注意：
    //对于一个给定的n，格雷码的序列不一定是唯一的，
    //例如：根据题目描述，[0,2,3,1]也是一个有效的格雷码序列
    //注意：题目描述的还不够清晰，要打印的是一个n位格雷码序列，这个序列恰好包含所有的n位代码
    //如n==2 就是将00 01 10 11 排列成格雷码

    //解法，动态规划，我们可以发现当拥有一个n==k的集合，其中所有的代码都不相同，那么我们只需要对每个代码在前面+0/1便可以构成一个
    //n==k+1的集合，其中所有的的代码都不相同，可用反证法证明。那么如果我们拥有n==k的格雷码，那么我们只需要先顺序的加0，再逆序的加1
    //便可以构成n==k+1的格雷码
    //如，00 01 11 10
    //我们先顺序加0，有：000 001 011 010 再逆序加一：110 111 101 100
    //于是有：000 001 011 010 110 111 101 100
    public ArrayList<Integer> grayCode(int n) {
        int[] tmp=new int[1<<n];
        for(int i=1;i<=n;i++){//每次得到第i层,第0层 tmp[0]=0
            int pow=1<<i;//0-(pow-1)
            int middle=1<<(i-1);
            for(int j=middle;j<pow;j++){
                tmp[j]=tmp[pow-j-1]|middle;
            }
        }
        ArrayList<Integer> res=new ArrayList<>();
        for(int i=0;i<tmp.length;i++)
            res.add(tmp[i]);
        return res;
    }
}
